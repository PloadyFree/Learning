Автолисп

	Сложный логический оператор (like switch)
		(COND
			((<AB1>) (<f1>))
			((<AB2>) (<f2>))
			...
			((<ABn>) (<fn>))
		)
		Если выполняется логичское выражение 1, то происходит выполнение функции f1
		После выполнния f1, управление передаётся на следующую функцию за COND
		
		(COND
			((< A B) (...))
			((= A B) (...))
			((> A B) (...))
			((/= A B) (...))
		)
	
	Расширенная функция работы со списками
		1. Списковое сложение
			(Append <L1> ... <Ln>)
			Соединяет списки L1 ... Ln в один список, при этом общий список хранится не как последовательность списков
				(SETQ L1 `(10 20 30))
				(SETQ L2 `(70 60 50))
				SETQ L3 (APPEND l1 l2))
				L3 -> 10 20 30 70 60 50
		2. Простой списковый цикл
			(apply '<f>' <L>)
			Выполняет функцию f над всеми элементами списка L
			
			(setq L (LIST 10 20 20))
			(setq A (Apply '+' L))
			(setq B (Apply 'MIN' L))
			(setq C (Apply 'ATAN' L))    L -> nil
			
			В кавычках может быть любая функция лиспа, в т.ч. пользовательская
		
		3. Ассоциативный поиск
			(Assoc <f> <L2>)
			Функция ищет f в списке L2, возвращает подсписок, начинающийся с f
			
			(setq L1 ("Кот" 20 0.5 "Пёс" 30 3.5))
			(setq A "Пёс")
			(setq L2 (Assoc A L1))
				L2 -> ("Пёс" 30 3.5)
			
		4. Включить новую голову в список
			
			(CONS <f> (L>))
			(command "_arc" '(300 300) '(700 300) '(700 700))
			
		5. Обработать список
			(For Each <Name> <L> <f>)
			Выполняет над каждым элементом списка L функцию f, помещая элемент списка в функцию Name, функция f обязательно должна иметь функцию Name
			
			(setq L(list 10 20 30))
			(setq L1 (For Each I L (+ I 2)))
				L1 -> (12 22 32)
			
			(setq L`("A" 30 "B"))
			(setq L1 (ForEach K L (* K 2)))
				L1 -> (nil 60 nil)
		
		6. (last <L>)
		7. (length <L>)
		8. (Reverse <L>)
		9. (MapCar 'f' <L1> ... <Ln>) - двойной списковый цикл
			(mapcar 'f' <L>) == apply
			выполняет функцию над каждым списком и возвращает соответствующий результат после этого
			(setq L `("A", 30, "B"))
			(setq L1 (list 10 20 50))
			(setq L3, (mapcar 'max' L L1))
				L3 -> nil
				L2 -> 50
				L3 -> (nil 50)
		10. (member <f> </>) - истина, если f находится в списке l
		(setq L `("A" 30 "B")
				(member 30 L) -> true
				(member `(30 "A") L) -> nil)
		11. (NTH <Number> <L>) - выделяем элемент с номером Number (1-indexing)
		12. Заменить жлемент списка на новый (subst <fnew> <fold> <L>)
		
	Функции работы со строками
		1. (strcase <str> [<flag>]) - перевести символы в строке в другой регистр, зависит от флага, если флаг = nil или опущен, то переводим все символы из нижнего регистра в верхний, если флаг равен истине, то наоборот
		2. (strcat <str1> <str2> ..) - объединить строки
		3. (strlen <str>) - длина строки
		4. (substr <str> <start> [<len>]) - возвращает строку str с символа start и длиной len, если она есть, если её нет, то до конца
		5. (match <str1> <str2>)
			первая - что ищем, вторая - где ищем (вроде регулярка) (* - любое число символов, # - любой символ буква или цифра, . - любой символ кроме буквы и цифры, ? - любой символ, [...-...] - символ входит в диапазон от первого значения до второго ([10-20], [~10-20] (не входит в диапазон)), , - знак логической операции И, ` - отменить проверку следующих символов)