Логическое программирование
	Для представления знания в языках программирования выделяют два альтернативных подхода:
		1. Процедурное представление - когда алгоритм решения задачи задаётся программистом
		2. Декларативное представление - когда программист не задаёт алгоритм решения, а определяет отдельные понятия, их состояния в различные моменты и связи между понятиями
		Декларативное представление наиболее чётко реализовано в алгоритмическом языке Пролог (ПРОграммисрование ЛОГическое)
		В данном языке факты представляют из себя логические формулы
		База знаний задаётся совокупностью этих формул
		Логические методы обеспечивают получение новых фактов из фактов, находящихся в базе знаний
		В процедурных и функциональных языках программист должен описать процесс решения задачи шаг за шагом
		В прологе он описывает саму проблему и основные правила её решения
		При этом, построение алгоритма решения остаётся за системой, поэтому декларативные языки считаются языками более высокого уровня, чем процедурные
		Пролог может использоваться для решения следующих задач:
			1. Разработка экспертных систем
			2. Доказательство теорем и выводов решений
			3. Разработка простых версий систем искуственного интеллекта
			4. Создание интерфейсов для связи существующих систем
			5. Перевод текстов с одного языка на другой, наиболее хорошо реализованный для языков программирования
		
		Метод резолюций
			Основой решения задачи в прологе является формальный логический вывод, который позволяет из группы выражений получить семантически правильное выражение, отличное от заданных
			В настоящее время существует два метода такого вывода:
				1. Естественный (натуральный) вывод - приближён к человеческим рассуждениям
				2. Метод резолюций - в его основе лежит исчесления резольвент
					Метод резольвент может работать над предикатами первого порядка
			Ограничения на логическое программирование
				Мы рассматриваем такие предикаты от x и y, которые не имеют функциональных зависимостей от других предикатов
			Идея метода резолюций заключается в том, что для доказательства ... (A1 v A2 ... An) -> B
			Доказательство происходит пошагово, если в процессе доказательства возникает противоречие между отрицанием гипотезы и аксиомами, то выдвинутая гипотеза правильна
			Доказательство выражается в нахождении пустого списка (дизъюнкта), так как количество аксиом А является конечным числом, то доказательство может быть составлено из конечных элементов и иметь конечное число шагов
			Предикаты рассматриваются в виде составного предиката, соединённого логическими операциями и кванторами существования и всеобщности.
			Так как одинаковые по смыслу предикаты могут иметь разный вид, то предложения (составной предикат) преобразуется в клаузальную форму - это разновидность конъюктивно-нормальной формы, в которой удалены кванторы существования, всеобщности, символы импликации, равнозначности и т.д.
			В клаузальной форме вся исходная логическая формула представляется в виде множества клаус Сi-х, объединяемых в клазульное множество S = C1 ^ c2 ^ ... ^ Cn
			Любое предложение Ci является совокупностью атомарных предикатов Сi = Pi1 v Pi2 v ... v Pini
			Предикат и его отрицания также называются дизъюнктом, литералом, атомом
			Сущность метода резолюций состит в проверке, содержит или не содержит множество S пустое предложение Cj
			Предложение Cj является пустым, если не содержит никаких литер
			Так как условием истинности S является истинность всех Ci, взодящих в S, то ложность какого-либо Ci заключается в том, что множество предикатов Pi1 ... Pini, образующее Ci, окажется пустым. Это указывает на ложность исходной логической формулы
			Если S содержит пустое предложение Ci, то S противоречиво, невыполнимо
			Рассматриваются все предложения Ci, пока не будет получено пустое
			Для того, чтобы ускорить вывод, ищутся такие предложения, в которых содержатся две переменные, одна из которых образует контрарную пару
			Если такие предложения обнаружены, то из этих двух предложений формируется новое предложение Q
			Предложение, сформированное из двух предложений C1 и C2 называется резольвентой
				Пример
					C1 : P v notQ v notR
					C2 : Q v P
					C3 : P v notR
			
			Пример
				Даны утверждения:
					Сократ - человек
					Человек - это живое существо
					Все живые существа смертны
				Требуется методом резолюций доказать, что Сократ смертен
				1 шаг - составить предикаты
					(A - для всех)
					A x (Человек (x) -> Живое существо (x))
					Человек(Сократ)
					A x (Живое существо(x) -> Смертно(x))
					Составляем дизъюгктивную форму по предикатам
					-(Человек(х) v Живое существо(х))
					-(Живое существо(х) v Смертно(х))
				2 шаг - отрицаем целевое выражение
					-Смертно(Сократ)
				3 шаг - составить конъюнкцию всех дизъюнктов (строя ... включая целевое выражение)
					(-(Человек(х) v Живое существо(х)) ^ (-(Живое существо(y) v Смертно(y)) ^ (-Человек(Сократ)) v (-Смертно(Сократ))
				4 шаг - в цикле проведём операцию поиска резольвент над каждой парой дизъюнктов
					1диз								|2диз
					-Человек(х) v Живое существо(х)		 -(Живое существо(y) v Смертно(y))
											-Человек(у) v Смертно(y)
					-Человек(y) v Смертно(y)			|Человек(Сократ)
												Смертно(Сократ)
					Смертно(Сократ)						|-Смертно(Сократ)
														0
			
		Структура программы на прологе
			Программа на языке пролог включает следующие разделы:
				Описание имён и структур объектов
					DOMAINS
				Описание предикатов названий отношений, существующих между объектами
					PREDICATES
				Описание фактов и правил, описывающих отношения
					CLAUSES
				Раздел целевых утверждений
					GOAL
				Последний раздел может не включаться в текст программы
				Он может быть вынесен в управляющую среду пролога
				Имена объектов, констант в прологе пишутся с маленькой буквы, а переменных - с большой
				В правилах импликация записывается :-